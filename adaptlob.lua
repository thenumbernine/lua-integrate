-- adaptivei lobatto
-- from 2000 Gander, Gautschi "Adaptive Quadrature-Revisited"

local math = require 'ext.math'	-- math.sign

local alpha = math.sqrt(2/3)
local beta = 1/math.sqrt(5)

--[[
%ADAPTLOBSTP Recursive function used by ADAPTLOB.
%
%	Q = ADAPTLOBSTP(’F’,A,B,FA,FB,IS,TRACE) tries to
%	approximate the integral of F(X) from A to B to
%	an appropriate relative error. The argument ’F’ is
%	a string containing the name of f. The remaining
%	arguments are generated by ADAPTLOB or by recursion.
%
%	See also ADAPTLOB.
%	Walter Gautschi, 08/03/98
--]]
local function adaptlobstp(f, a, b, fa, fb, is, ...)
	local h=(b-a)/2
	local m=(a+b)/2
	local mll=m-alpha*h
	local ml=m-beta*h
	local mr=m+beta*h
	local mrr=m+alpha*h
	
	local fmll = f(mll, ...)
	local fml = f(ml, ...)
	local fm = f(m, ...)
	local fmr = f(mr, ...)
	local fmrr = f(mrr, ...)
	
	local i2=(h/6)*(fa+fb+5*(fml+fmr))
	local i1=(h/1470)*(77*(fa+fb)+432*(fmll+fmrr)+625*(fml+fmr) 
		+672*fm)
	if (is+(i1-i2)==is) or (mll<=a) or (b<=mrr) then
--[[		
		if ((m <= a) | (b<=m)) & (termination2==0) then
			warning("Interval contains no more machine number. Required tolerance may not be met.")
			termination2 =1
		end
		if trace then disp([a b-a Q]) end
--]]		
		return i1
	else
		return adaptlobstp(f, a, mll, fa, fmll, is, ...)+
			adaptlobstp(f, mll, ml, fmll, fml, is, ...)+
			adaptlobstp(f, ml, m, fml, fm, is, ...)+
			adaptlobstp(f, m, mr, fm, fmr, is, ...)+
			adaptlobstp(f, mr, mrr, fmr, fmrr, is, ...)+
			adaptlobstp(f, mrr, b, fmrr, fb, is, ...)
	end
end

--[[
%ADAPTLOB Numerically evaluate integral using adaptive
%	Lobatto rule.
%
%	Q=ADAPTLOB(’F’,A,B) approximates the integral of
%	F(X) from A to B to machine precision. ’F’ is a
%	string containing the name of the function. The
%	function F must return a vector of output values if
%
%	given a vector of input values.
%	Q=ADAPTLOB(’F’,A,B,TOL) integrates to a relative
%	error of TOL.
%	Q=ADAPTLOB(’F’,A,B,TOL,TRACE) displays the left
%	end point of the current interval, the interval
%	length, and the partial integral.
%	Q=ADAPTLOB(’F’,A,B,TOL,TRACE,P1,P2,...) allows
%	coefficients P1,... to be passed directly to the
%	function F: G=F(X,P1,P2,...). To use default values
%	for TOL or TRACE, one may pass the empty matrix ([]).
%	See also ADAPTLOBSTP.
%	Walter Gautschi, 08/03/98
%	Reference: Gander, Computermathematik, Birkhaeuser, 1992.
--]]
-- if we set tol to eps then why do we use tol / eps ?
--local eps = 1e-7
local eps = 1e-15
local function adaptlob(f, a, b, tol, ...)
	--tol = math.max(tol or eps, eps)
	tol = tol or eps

	local m=(a+b)/2
	local h=(b-a)/2
	
	local x1=.942882415695480
	local x2=.641853342345781
	local x3=.236383199662150
	
	local y1 = f(a, ...)
	local y2 = f(m-x1*h, ...)
	local y3 = f(m-alpha*h, ...)
	local y4 = f(m-x2*h, ...)
	local y5 = f(m-beta*h, ...)
	local y6 = f(m-x3*h, ...)
	local y7 = f(m, ...)
	local y8 = f(m+x3*h, ...)
	local y9 = f(m+beta*h, ...)
	local y10 = f(m+x2*h, ...)
	local y11 = f(m+alpha*h, ...)
	local y12 = f(m+x1*h, ...)
	local y13 = f(b, ...)

	local fa=y1
	local fb=y13
	local i2=(h/6)*(y1+y13+5*(y5+y9))
	local i1=(h/1470)*(77*(y1+y13)+432*(y3+y11)+ 
		625*(y5+y9)+672*y7)
	local is=h*(.0158271919734802*(y1+y13)+.0942738402188500 
		*(y2+y12)+.155071987336585*(y3+y11)+
		.188821573960182*(y4+y10)+.199773405226859
		*(y5+y9)+.224926465333340*(y6+y8)
		+.242611071901408*y7)
	local s = math.sign(is)
	if s==0 then s=1 end
	local erri1 = math.abs(i1-is)
	local erri2 = math.abs(i2-is)
	local R=1
	if erri2 ~= 0 then R = erri1/erri2 end
	if R>0 and R<1 then tol = tol/R end
	is = s*math.abs(is) * tol/eps
	if is==0 then is = b-a end
	return adaptlobstp(f, a, b, fa, fb, is, ...)
end

return adaptlob
